#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/miscdevice.h>
#include <linux/mm.h>
#include <linux/io.h>
#include <linux/acpi.h>
#include <linux/list.h>

MODULE_LICENSE("GPL");

/*
 * ACPI for Arm Components Platform Design Document
 * https://developer.arm.com/documentation/den0093/latest
 *
 * Table 13: Arm CMN-xy0 HID values (page-17)
 * +------------------------------------------------------+
 * |Value     Description                                 |
 * +------------------------------------------------------+
 * |ARMHC600  ACPI Hardware Identifier for the CMN-600 PMU|
 * |ARMHC650  ACPI Hardware Identifier for the CMN-650 PMU|
 * |ARMHC700  ACPI Hardware Identifier for the CMN-700 PMU|
 * +------------------------------------------------------+
 *
 * Table 16: Arm CMN-xy0 Coherent Mesh Network configuration objects (page-19)
 * +--------------------------------------------------------------------------+
 * |Object Values       Type         Description                              |
 * +--------------------------------------------------------------------------+
 * |_CRS   PERIPHBASE   QWordMemory  Base address of the memory-mapped        |
 * |                                 region in the system address map where   |
 * |                                 the CMN-xy0 registers are mapped.        |
 * |       ROOTNODEBASE QWordMemory  Base address of the root node. This field|
 * |                                 is specific to the CMN-600 device object.|
 * |       GSIV[n]      Interrupt    List of GSIVs of n distinct interrupts   |
 * |                                 that can be generated by the n PMUs      |
 * |                                 located in this instance of the CMN-xy0. |
 * +--------------------------------------------------------------------------+
 */

struct cmn_device {
    char name[32];
    u64 io_base;
    u64 io_size;
    int misc_dev_registered;
    struct miscdevice misc_dev;
    struct list_head list;
};

static LIST_HEAD(cmn_dev_list_);

// called for each cmn acpi device
static acpi_status __init cmn_get_acpi_resource(struct acpi_resource *res,
                                                void *ctx)
{
    struct cmn_device *cmn_dev = (struct cmn_device *)ctx;
    if (res->type == ACPI_RESOURCE_TYPE_ADDRESS64) {
        const u64 base = res->data.address64.address.minimum;
        const u64 size = res->data.address64.address.address_length;
        if (cmn_dev->io_base == 0 && cmn_dev->io_size == 0) {
            cmn_dev->io_base = base;
            cmn_dev->io_size = size;
        } else {
            pr_warn("Duplicated CMN resource\n");
        }
    }
    return AE_OK;
}

// called for each acpi device under \_SB
static acpi_status __init cmn_get_acpi_dev(acpi_handle handle, u32 level,
                                           void *, void **)
{
    acpi_status status;
    struct acpi_buffer buf;
    struct acpi_device_info *info;
    struct cmn_device *cmn_dev;

    status = acpi_get_object_info(handle, &info);
    if (ACPI_FAILURE(status)) {
        pr_err("Failed to get object info\n");
        return status;
    }

    if (info->type == ACPI_TYPE_DEVICE && info->hardware_id.string) {
        status = AE_ERROR;
        if (strcmp(info->hardware_id.string, "ARMHC600") == 0 ||
            strcmp(info->hardware_id.string, "ARMHC650") == 0) {
            pr_err("Unsupported CMN version: %s\n", info->hardware_id.string);
            goto done;
        }
        if (strcmp(info->hardware_id.string, "ARMHC700") == 0) {
            cmn_dev = kzalloc(sizeof(struct cmn_device), GFP_KERNEL);
            buf.pointer = cmn_dev->name;
            buf.length = sizeof(cmn_dev->name) - 1;
            status = acpi_get_name(handle, ACPI_SINGLE_NAME, &buf);
            if (ACPI_FAILURE(status)) {
                pr_err("Failed to get dev name\n");
                kfree(cmn_dev);
                goto done;
            }
            status = acpi_walk_resources(handle, METHOD_NAME__CRS,
                                         cmn_get_acpi_resource, cmn_dev);
            if (ACPI_FAILURE(status)) {
                pr_err("Failed to walk resource: \\_SB\\%s\n", cmn_dev->name);
                kfree(cmn_dev);
                goto done;
            }
            // append device to list
            INIT_LIST_HEAD(&cmn_dev->list);
            list_add_tail(&cmn_dev->list, &cmn_dev_list_);
        }
    }

    status = AE_OK;
done:
    kfree(info);
    return status;
}

// scan acpi devices to find cmn devices
static int __init cmn_find_dev(void)
{
    acpi_status status;
    acpi_handle sb_handle;

    status = acpi_get_handle(NULL, "\\_SB", &sb_handle);
    if (ACPI_FAILURE(status)) {
        pr_err("Failed to get handle of \\_SB\n");
        return -ENODEV;
    }
    status = acpi_walk_namespace(ACPI_TYPE_DEVICE, sb_handle, ACPI_UINT32_MAX,
                                 cmn_get_acpi_dev, NULL, NULL, NULL);
    if (ACPI_FAILURE(status)) {
        pr_err("Failed to walk \\_SB tree\n");
        return -ENODEV;
    }

    if (list_empty(&cmn_dev_list_)) {
        pr_err("No CMN device found in ACPI table\n");
        return -ENODEV;
    }
    return 0;
}

static int cmn_open(struct inode *, struct file *filp)
{
    struct miscdevice *misc_dev = filp->private_data;
    struct cmn_device *cmn_dev =
        container_of(misc_dev, struct cmn_device, misc_dev);
    filp->private_data = cmn_dev;
    return 0;
}

static int cmn_mmap(struct file *filp, struct vm_area_struct *vma)
{
    struct cmn_device *cmn_dev = filp->private_data;
    const unsigned long size = vma->vm_end - vma->vm_start;
    const unsigned long off = vma->vm_pgoff << PAGE_SHIFT;

    if (off >= cmn_dev->io_size || size > cmn_dev->io_size - off)
    {
        pr_err("Out of address range\n");
        return -EINVAL;
    }

    vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
    if (io_remap_pfn_range(vma, vma->vm_start,
                           PFN_DOWN(cmn_dev->io_base + off), size,
                           vma->vm_page_prot)) {
        pr_err("Failed to map io memory\n");
        return -EAGAIN;
    }

    return 0;
}

static const struct file_operations cmn_fops = {
    .owner = THIS_MODULE,
    .open = cmn_open,
    .mmap = cmn_mmap,
};

static int __init cmn_init(void) {
    int ret;
    struct cmn_device *cmn_dev;

    ret = cmn_find_dev();
    if (ret < 0)
        return ret;

    list_for_each_entry(cmn_dev, &cmn_dev_list_, list) {
        char dev_name[64];

        pr_info("Found CMN device: %s\n", cmn_dev->name);
        pr_info("  io_base = %llx\n", cmn_dev->io_base);
        pr_info("  io_size = %llx\n", cmn_dev->io_size);

        snprintf(dev_name, sizeof(dev_name), "armcmn:%s:%llx:%llx",
                 cmn_dev->name, cmn_dev->io_base, cmn_dev->io_size);
        cmn_dev->misc_dev.name = kstrdup(dev_name, GFP_KERNEL);
        cmn_dev->misc_dev.minor = MISC_DYNAMIC_MINOR;
        cmn_dev->misc_dev.fops = &cmn_fops;
        cmn_dev->misc_dev.mode = 0666;
        ret = misc_register(&cmn_dev->misc_dev);
        if (ret) {
            pr_err("Failed to register device %s\n", dev_name);
            return ret;
        }
        cmn_dev->misc_dev_registered = 1;
    }

    return 0;
}

static void __exit cmn_exit(void) {
    struct cmn_device *cmn_dev, *tmp;

    list_for_each_entry_safe(cmn_dev, tmp, &cmn_dev_list_, list) {
        if (cmn_dev->misc_dev.name) {
            kfree(cmn_dev->misc_dev.name);
        }
        if (cmn_dev->misc_dev_registered) {
            misc_deregister(&cmn_dev->misc_dev);
        }
        list_del(&cmn_dev->list);
        kfree(cmn_dev);
    }
}

module_init(cmn_init);
module_exit(cmn_exit);
